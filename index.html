<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WOSO Couples Chart</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
    html, body { margin: 0; padding: 0; height: 100%; width: 100%; }
    #mynetwork { width: 100%; height: 100%; }
    form { position: absolute; background: #898989; z-index: 10; padding: 10px; border-radius: 0 0 5px 0; }
    button.action { margin-top: 5px; width: 100%; padding: 5px; font-size: 14px; cursor: pointer; }
    #nodeTooltip {
      position: absolute;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 13px;
      max-width: 250px;
      z-index: 99999;
      display: none;
      pointer-events: none;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      transition: opacity 0.15s ease-in-out;
      opacity: 0;
    }
  </style>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script src="data.js"></script>
  <script>
    let network;
    let nodes = new vis.DataSet();
    let edges = new vis.DataSet();
    let originalNodes = [];
    let originalEdges = [];
    let lookupCount = 0;
    let physicsEnabled = true;
    let longestPathCache = new Map();
    
    function loadData() {
      const graph = window.graphData;
      originalNodes = graph.nodes.map(n => ({ ...n }));
      originalEdges = graph.edges.map((e, i) => ({ id: e.id || ("e" + i), ...e }));
    
      nodes = new vis.DataSet(originalNodes);
      edges = new vis.DataSet(originalEdges);
    
      computeAllLongestPaths();
      draw();
    }
    
    function computeAllLongestPaths() {
      originalNodes.forEach(node => {
        longestPathCache.set(node.id, getLongestPathLength(node.id));
      });
    }
    
    function getLongestPathLength(startId) {
      if (longestPathCache.has(startId)) return longestPathCache.get(startId);
      let maxLength = 0;
      function dfs(nodeId, path) {
        path.push(nodeId);
        if (path.length > maxLength) maxLength = path.length;
        const neighbors = originalEdges
          .filter(e => e.from === nodeId || e.to === nodeId)
          .map(e => e.from === nodeId ? e.to : e.from);
        neighbors.forEach(n => {
          if (!path.includes(n)) dfs(n, [...path]);
        });
      }
      dfs(startId, []);
      longestPathCache.set(startId, maxLength);
      return maxLength;
    }

    function getLongestPath(startId) {
      const visited = new Set([startId]);
      const queue = [{ id: startId, dist: 0, path: [startId], edges: [] }];
      let best = { length: 0, pathNodes: [startId], pathEdges: [] };
      
      while (queue.length) {
        const { id, dist, path, edges: edgesPath } = queue.shift();
      
        if (dist > best.length) {
          best = { length: dist, pathNodes: [...path], pathEdges: [...edgesPath] };
        }
      
        originalEdges.forEach(edge => {
          let neighbor = null;
          if (edge.from === id) neighbor = edge.to;
          else if (edge.to === id) neighbor = edge.from;
      
          if (neighbor && !visited.has(neighbor)) {
            visited.add(neighbor);
            queue.push({
              id: neighbor,
              dist: dist + 1,
              path: [...path, neighbor],
              edges: [...edgesPath, edge.id]
            });
          }
        });
      }
      
      return best; // length = number of edges to farthest node
    }   
     let previouslyHighlightedEdges = [];
     let previouslyHighlightedNodes = [];
     
     function highlightPath(pathNodes, pathEdges) {
       // Reset widths of previously highlighted edges
       if (previouslyHighlightedEdges.length) {
         edges.update(previouslyHighlightedEdges.map(id => ({ id, width: 1 })));
       }
     
       // Reset sizes of previously highlighted nodes
       if (previouslyHighlightedNodes.length) {
         nodes.update(previouslyHighlightedNodes.map(id => ({ id, size: 30 })));
       }
     
       // Apply new highlight (thicker edges, larger nodes)
       edges.update(pathEdges.map(id => ({ id, width: 4 })));
       nodes.update(pathNodes.map(id => ({ id, size: 40 })));
     
       // Remember which were changed
       previouslyHighlightedEdges = pathEdges;
       previouslyHighlightedNodes = pathNodes;
     
       // Still mark them as "selected" so dimming works as usual
       network.selectNodes(pathNodes);
       network.selectEdges(pathEdges);
     }

	
	
    function draw() {
      const container = document.getElementById("mynetwork");
      const data = { nodes, edges };
      const options = {
        nodes: { shape: "circularImage", borderWidth: 2, size: 30, font: { size: 16, color: "#000" } },
        edges: { width: 1, color: { color: "#888", opacity: 0.4 }, smooth: { type: "continuous" } },
        physics: {
          enabled: true,
          solver: "forceAtlas2Based",
          forceAtlas2Based: { centralGravity: 0.001, springLength: 180, springConstant: 0.02, damping: 0.09, avoidOverlap: 0.8 },
          stabilization: { iterations: 700, fit: true }
        },
        layout: { improvedLayout: false },
        interaction: { hover: true, dragNodes: true, navigationButtons: false, keyboard: true }
      };
      network = new vis.Network(container, data, options);
      network.once("stabilizationIterationsDone", () => network.setOptions({ physics: { enabled: false } }));
    
      const tooltip = document.getElementById("nodeTooltip");
      let tooltipVisible = false;

      // Tooltip + highlight longest path
      network.on("hoverNode", params => {
      const node = nodes.get(params.node);
      if (!node) return;
	  // Hide tooltip only (keep highlight)
      network.on("blurNode", () => {
        tooltip.style.opacity = "0";
        setTimeout(() => {
          tooltip.style.display = "none";
        }, 150); // match CSS transition
        tooltipVisible = false;
      });
	  
      // clear previous highlight
      network.unselectAll();
    
      // compute longest path from hovered node
      const { length, pathNodes, pathEdges } = getLongestPath(node.id);
    
      // build tooltip
      let html = `<strong>${node.label}</strong><br>`;
      if (node.team) html += `Team: ${node.team}<br>`;
      if (node.group) html += `Country: ${node.group}<br>`;
      html += `Longest chain: ${length}`;
    
      tooltip.innerHTML = html;
      tooltip.style.display = "block";
      requestAnimationFrame(() => { tooltip.style.opacity = "1"; });
      tooltipVisible = true;
    
      // highlight path
      highlightPath(pathNodes, pathEdges);

    });

      container.addEventListener("mousemove", ev => {
        if (!tooltipVisible) return;
        const offset = 12;
        let x = ev.clientX + offset;
        let y = ev.clientY + offset;
        const pad = 8;
        const w = tooltip.offsetWidth || 200;
        const h = tooltip.offsetHeight || 40;
        if (x + w > window.innerWidth - pad) x = window.innerWidth - w - pad;
        if (y + h > window.innerHeight - pad) y = ev.clientY - h - offset;
        tooltip.style.left = x + "px";
        tooltip.style.top = y + "px";
      });
    }
    
    function togglePhysics() {
      physicsEnabled = !physicsEnabled;
      network.setOptions({ physics: { enabled: physicsEnabled } });
      document.getElementById("physicsIcon").className = physicsEnabled ? "fas fa-pause" : "fas fa-play";
    }
    
    let searchMatches = [];   // store matches for cycling
    let searchIndex = 0;      // track which one weâ€™re on
    
    function highlightNode() {
      const raw = document.getElementById("lname").value || "";
      if (!raw.trim()) return;
    
      // Parse criteria the same way filterGraph() does
      const criteria = [];
      const regex = /(?:\b(team|group|label|name):(?:"([^"]+)"|'([^']+)'|([^\s,]+))|"(.*?)"|'(.*?)'|([^\s,]+))/gi;
      let m;
      while ((m = regex.exec(raw)) !== null) {
        if (m[1]) {
          const key = m[1].toLowerCase();
          const val = (m[2] || m[3] || m[4] || "").toLowerCase().trim();
          if (val) criteria.push({ field: key, value: val });
        } else {
          const val = (m[5] || m[6] || m[7] || "").toLowerCase().trim();
          if (val) criteria.push({ field: "any", value: val });
        }
      }
      if (!criteria.length) return;
    
      // Get all matches (within currently visible nodes)
      const allNodes = nodes.get();
      const matches = allNodes.filter(n => {
        const label = (n.label || "").toLowerCase();
        const team = (n.team || "").toLowerCase();
        const group = (n.group || "").toLowerCase();
        return criteria.every(c => {
          if (c.field === "team") return team.includes(c.value);
          if (c.field === "group") return group.includes(c.value);
          if (c.field === "label" || c.field === "name") return label.includes(c.value);
          return label.includes(c.value) || team.includes(c.value) || group.includes(c.value);
        });
      });
    
      if (!matches.length) {
        console.warn("No nodes matched search.");
        return;
      }
    
      // Reset stored matches if new query
      const currentQuery = JSON.stringify(criteria);
      if (!searchMatches.query || searchMatches.query !== currentQuery) {
        searchMatches = { nodes: matches, query: currentQuery };
        searchIndex = 0;
      }
    
      // Cycle through matches
      const target = searchMatches.nodes[searchIndex % searchMatches.nodes.length];
      searchIndex++;
    
      // Focus camera + select node
      const opts = { 
        scale: 1.5, 
        offset: { x: 0, y: 0 }, 
        animation: { duration: 800, easingFunction: "easeInOutQuad" } 
      };
      network.focus(target.id, opts);
      network.selectNodes([target.id]);
    }

    
       function filterGraph() {
          const raw = document.getElementById("lname").value || "";
          if (!raw.trim()) { resetGraph(); return; }
        
          // Parse tokens
          const criteria = [];
          const regex = /(?:\b(team|group|label|name):(?:"([^"]+)"|'([^']+)'|([^\s,]+))|"(.*?)"|'(.*?)'|([^\s,]+))/gi;
          let m;
          while ((m = regex.exec(raw)) !== null) {
            if (m[1]) {
              const key = m[1].toLowerCase();
              const val = (m[2] || m[3] || m[4] || "").toLowerCase().trim();
              if (val) criteria.push({ field: key, value: val });
            } else {
              const val = (m[5] || m[6] || m[7] || "").toLowerCase().trim();
              if (val) criteria.push({ field: "any", value: val });
            }
          }
        
          if (!criteria.length) { resetGraph(); return; }
        
          // match ALL criteria
          const matches = originalNodes.filter(n => {
            const label = (n.label || "").toLowerCase();
            const team = (n.team || "").toLowerCase();
            const group = (n.group || "").toLowerCase();
            return criteria.every(c => {
              if (c.field === "team") return team.includes(c.value);
              if (c.field === "group") return group.includes(c.value);
              if (c.field === "label" || c.field === "name") return label.includes(c.value);
              return label.includes(c.value) || team.includes(c.value) || group.includes(c.value);
            });
          });
        
          // ðŸš« If no matches â†’ do nothing
          if (!matches.length) {
            console.warn("No nodes matched. Graph unchanged.");
            return;
          }
        
          // Expand to neighbors
          const included = new Set(matches.map(n => String(n.id)));
          const queue = matches.map(n => String(n.id));
          while (queue.length) {
            const id = queue.shift();
            for (const e of originalEdges) {
              const from = String(e.from);
              const to = String(e.to);
              if (from === id && !included.has(to)) { included.add(to); queue.push(to); }
              if (to === id && !included.has(from)) { included.add(from); queue.push(from); }
            }
          }
        
          nodes.clear();
          nodes.add(originalNodes.filter(n => included.has(String(n.id))));
        
          edges.clear();
          edges.add(originalEdges.filter(e =>
            included.has(String(e.from)) && included.has(String(e.to))
          ));
        
          previouslyHighlightedEdges = [];
          previouslyHighlightedNodes = [];
          network.unselectAll();
        
          network.setOptions({ physics: { enabled: true } });
          network.fit({ animation: { duration: 500, easingFunction: "easeInOutQuad" } });
          network.once("stabilizationIterationsDone", () => network.setOptions({ physics: { enabled: false } }));
        }


       function resetGraph() {
     // clear the search box
     document.getElementById("lname").value = "";
    
     // restore full graph
     nodes.clear(); 
     nodes.add(originalNodes);
     edges.clear(); 
     edges.add(originalEdges);
    
     // enable physics briefly, fit view, then disable physics again
     network.setOptions({ physics: { enabled: true } });
     network.fit({ animation: { duration: 500, easingFunction: "easeInOutQuad" } });
     network.once("stabilizationIterationsDone", () => 
       network.setOptions({ physics: { enabled: false } })
     );
    }
    window.onload = loadData;
  </script>
  </head>
  <body>
    <form action="javascript:void(0);">
      <input type="text" id="lname" placeholder="Search by player, team, or country" style="width:180px"><br>
      <button type="button" class="action" onclick="highlightNode()">Search</button>
      <button type="button" class="action" onclick="filterGraph()">Filter</button>
      <button type="button" class="action" onclick="resetGraph()">Reset</button>
      <button type="button" class="action" onclick="togglePhysics()"><i id="physicsIcon" class="fas fa-pause"></i></button>
    </form>
    
    <div id="mynetwork"></div>
    <div id="nodeTooltip"></div>
  </body>
  </html>
